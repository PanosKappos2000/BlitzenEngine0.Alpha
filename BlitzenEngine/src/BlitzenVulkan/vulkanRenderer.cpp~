#include "VulkanRenderer.h"

//Includes the Vulkan Memory Allocator with function definitions
#define VMA_IMPLEMENTATION
#include "vma/vk_mem_alloc.h"

//Includes functions that initalize some key Vulkan SDK structs
#include "vulkanSDKobjects.h"

namespace BlitzenRendering
{
    VulkanRenderer::VulkanRenderer()
    {

    }

    void VulkanRenderer::Init(WindowData* pWindowData)
    {
        vkb::Instance vkbInstance = BootstrapCreateInstance();

        //Passing the window data, since the GLFW window will be needed to create the window surface
        m_pWindowData = pWindowData;

        //Window surface created before GPU selection, so that the surface can be passed to the GPU handle
        glfwCreateWindowSurface(m_bootstrapObjects.vulkanInstance, 
            m_pWindowData->pWindow, nullptr, &(m_bootstrapObjects.windowSurface));

        //GPU selection and device creation
        BootstrapSelectGPUAndCreateDevice(vkbInstance);

        //Initialize the allocator for buffers and images
        InitAllocator();

        //Intialize the swapchain
        BootstrapCreateSwapchain();

        //Allocate the command buffer that will be used for quick commands outside the main loop
        m_instantSubmit.Init(m_device, m_queues.graphicsQueueFamilyIndex, &(m_queues.graphicsQueue));

        //Create the command buffers, semaphores and fences that will be used in the draw frame function
        InitFrameTools();

        //Allocate the color attachment
        AllocateImage(m_colorAttachmentImage, {(uint32_t)m_pWindowData->windowWidth, (uint32_t)m_pWindowData->windowHeight, 1}, 
        VK_FORMAT_R16G16B16A16_SFLOAT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | 
        VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_STORAGE_BIT);

        //Allocate the depth stencil attachment
        AllocateImage(m_depthAttachmentImage, m_colorAttachmentImage.extent, VK_FORMAT_D32_SFLOAT, 
        VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT);

        std::vector<VulkanVertex> vertices(4);
        vertices[0].position = glm::vec3(-0.5f, 0.5f, 0.f);
        vertices[0].color = glm::vec4(1.f, 0.f, 0.f, 1.f);
        vertices[1].position = glm::vec3(-0.5f, -0.5f, 0.f);
        vertices[1].color = glm::vec4(0.f, 1.f, 0.f, 1.f);
        vertices[2].position = glm::vec3(0.5f, -0.5f, 0.f);
        vertices[2].color = glm::vec4(0.f, 0.f, 1.f, 1.f);
        vertices[3].position = glm::vec3(0.5f, 0.5f, 0.f);
        vertices[3].color = glm::vec4(0.f, 0.f, 0.f, 1.f);
        std::vector<uint32_t> indices(6);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 2;
        indices[4] = 3;
        indices[5] = 0;
        LoadMeshBuffers(m_placeholderMesh, vertices, indices);

        //Initialize the graphics pipeline builder and build a basic pipeline to draw the triangle
        m_graphicsPipelineBuilder.Init(&m_device);
        m_graphicsPipelineBuilder.BuildBasicOpaqueSurfacePipeline(&m_placeholderPipeline, &m_placeholderPipelineLayout, 
        &m_colorAttachmentImage.format, 1, m_depthAttachmentImage.format, VK_FORMAT_UNDEFINED);
    }

    vkb::Instance VulkanRenderer::BootstrapCreateInstance()
    {
        vkb::InstanceBuilder vkbInstanceBuilder;

        vkbInstanceBuilder.set_app_name("Blitzen Vulkan Renderer");
	    vkbInstanceBuilder.request_validation_layers(m_bootstrapObjects.bEnableValidationLayers); 
	    vkbInstanceBuilder.use_default_debug_messenger();
	    vkbInstanceBuilder.require_api_version(1, 3, 0);

        //VkbInstance built to initialize instance and debug messenger
        auto vkbInstanceBuilderResult = vkbInstanceBuilder.build();
        vkb::Instance vkbInstance = vkbInstanceBuilderResult.value();

        //Instance reference from vulkan data initialized
        m_bootstrapObjects.vulkanInstance = vkbInstance.instance;

        //Debug Messenger reference from vulkan data initialized
        m_bootstrapObjects.debugMessenger = vkbInstance.debug_messenger;

        //The vkbInstance will be used by VkBootstrap again to select the GPU
        return vkbInstance;
    }

    void VulkanRenderer::BootstrapSelectGPUAndCreateDevice(const vkb::Instance& vkbInstance)
    {
        //Setting desired vulkan 1.3 features
        VkPhysicalDeviceVulkan13Features vulkan13Features{};
        vulkan13Features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
        //Using dynamic rendering since the engine will not benefit from the VkRenderPass
        vulkan13Features.dynamicRendering = true;
        vulkan13Features.synchronization2 = true;

        //Setting desired vulkan 1.2 features
        VkPhysicalDeviceVulkan12Features vulkan12Features{};
        vulkan12Features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
        //Will allow us to create GPU pointers to access storage buffers
        vulkan12Features.bufferDeviceAddress = true;
        vulkan12Features.descriptorIndexing = true;

        //vkbDeviceSelector built with reference to vkbInstance built earlier
        vkb::PhysicalDeviceSelector vkbDeviceSelector{ vkbInstance };
        vkbDeviceSelector.set_minimum_version(1, 3);
        vkbDeviceSelector.set_required_features_13(vulkan13Features);
        vkbDeviceSelector.set_required_features_12(vulkan12Features);
        vkbDeviceSelector.set_surface(m_bootstrapObjects.windowSurface);

        //Selecting the GPU and giving its value to the vkb::PhysicalDevice handle
        vkb::PhysicalDevice vkbPhysicalDevice = vkbDeviceSelector.select().value();

        //Saving the actual vulkan gpu handle 
        m_bootstrapObjects.chosenGPU = vkbPhysicalDevice.physical_device;

        //Setting up the vkDevice based on the chosen gpu
        vkb::DeviceBuilder vkbDeviceBuilder{ vkbPhysicalDevice };
        vkb::Device vkbDevice = vkbDeviceBuilder.build().value();
        //Savign the actula vulkan device
        m_device = vkbDevice.device;

        //Setting up the graphics queue and its queue family index
        m_queues.graphicsQueue = vkbDevice.get_queue(vkb::QueueType::graphics).value();
        m_queues.graphicsQueueFamilyIndex = vkbDevice.get_queue_index(
            vkb::QueueType::graphics).value();

        //Setting up the present queue and its queue family index
        m_queues.presentQueue = vkbDevice.get_queue(vkb::QueueType::present).value();
        m_queues.presentQueueFamilyIndex = vkbDevice.get_queue_index(
            vkb::QueueType::present).value();
    }

    void VulkanRenderer::InitAllocator()
    {
        VmaAllocatorCreateInfo allocatorInfo{};
        allocatorInfo.device = m_device;
        allocatorInfo.instance = m_bootstrapObjects.vulkanInstance;
        allocatorInfo.physicalDevice = m_bootstrapObjects.chosenGPU;
        allocatorInfo.flags = VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT;

        vmaCreateAllocator(&allocatorInfo, &m_allocator);
    }

    void VulkanRenderer::BootstrapCreateSwapchain()
    {
        vkb::SwapchainBuilder vkSwapBuilder{ m_bootstrapObjects.chosenGPU, m_device, m_bootstrapObjects.windowSurface };

        //Setting the desired image format
        m_bootstrapObjects.swapchainData.imageFormat = VK_FORMAT_B8G8R8A8_UNORM;

        vkb::Result<vkb::Swapchain> vkbSwapBuilderResult = vkSwapBuilder.set_desired_format(VkSurfaceFormatKHR{ 
            m_bootstrapObjects.swapchainData.imageFormat, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR }) //Setting the desrired surface format
        	.set_desired_present_mode(VK_PRESENT_MODE_FIFO_KHR)//Setting the present mode to be limited to the speed of the monitor
        	.set_desired_extent(m_pWindowData->windowWidth, m_pWindowData->windowHeight)
        	.add_image_usage_flags(VK_IMAGE_USAGE_TRANSFER_DST_BIT)
        	.build();

        //Building the vkb swapchain so that the swapchain data can be retrieved
        vkb::Swapchain vkbSwapchain = vkbSwapBuilderResult.value();

        //Setting the actual vulkan swapchain struct
        m_bootstrapObjects.swapchainData.swapchain = vkbSwapchain.swapchain;

        //Saving the swapchain's window extent
        m_bootstrapObjects.swapchainData.swapchainExtent = vkbSwapchain.extent;

        //Saving the swapchain images, they will be used each frame to present the render result to the swapchain
        m_bootstrapObjects.swapchainData.swapchainImages = vkbSwapchain.get_images().value();

        //Saving the swapchain image views, they will be used to access each swapchain image
        m_bootstrapObjects.swapchainData.swapchainImageViews = vkbSwapchain.get_image_views().value();
    }




    void VulkanRenderer::InitFrameTools()
    {
        VkCommandPoolCreateInfo commandPoolInfo{};
        //Each command buffer will be created so that it can be individually reset
        VulkanSDKobjects::CommandPoolCreateInfoInit(commandPoolInfo, m_queues.graphicsQueueFamilyIndex, 
        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);

        VkSemaphoreCreateInfo semaphoreInfo{};
        VulkanSDKobjects::SemaphoreCreateInfoInit(semaphoreInfo);

        //The in flight fences will be creted in the signaled state, so that the 1st does not deadlock
        VkFenceCreateInfo fenceInfo{};
        VulkanSDKobjects::FenceCreateInfoInit(fenceInfo, VK_FENCE_CREATE_SIGNALED_BIT);

        for(size_t i = 0; i < m_frameToolList.size(); ++i)
        {
            vkCreateFence(m_device, &fenceInfo, nullptr, &(m_frameToolList[i].inFlightFence));

            vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &(m_frameToolList[i].renderFinishedSemaphore));

            vkCreateSemaphore(m_device, &semaphoreInfo, nullptr, &(m_frameToolList[i].imageAvailableSemaphore));

            vkCreateCommandPool(m_device, &commandPoolInfo, nullptr, &(m_frameToolList[i].renderCommandPool));

            /*-----------------------------------------------------------------------
            Since each command buffer will be allocated by a different command pool, 
            every command buffer will have a different create info struct
            -------------------------------------------------------------------------*/
            VkCommandBufferAllocateInfo commandBufferInfo{};
            VulkanSDKobjects::CommandBufferAllocInfoInit(commandBufferInfo, (m_frameToolList[i].renderCommandPool), 
            VK_COMMAND_BUFFER_LEVEL_PRIMARY);
            vkAllocateCommandBuffers(m_device, &commandBufferInfo, &(m_frameToolList[i].renderCommandBuffer));
        }
    }




    void OneTimeCommands::Init(const VkDevice& m_device, uint32_t queueFamilyIndex, VkQueue* queue)
    {
        submitQueue = queue;
        submitQueueFamilyIndex = queueFamilyIndex;

        VkCommandPoolCreateInfo commandPoolInfo{};
        VulkanSDKobjects::CommandPoolCreateInfoInit(commandPoolInfo, queueFamilyIndex, 
        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
        vkCreateCommandPool(m_device, &commandPoolInfo, nullptr, &commandPool);

        VkCommandBufferAllocateInfo commandBufferInfo{};
        VulkanSDKobjects::CommandBufferAllocInfoInit(commandBufferInfo, commandPool, 
        VK_COMMAND_BUFFER_LEVEL_PRIMARY);
        vkAllocateCommandBuffers(m_device, &commandBufferInfo, &commandBuffer);
    }

    void OneTimeCommands::StartRecording()
    {
        vkResetCommandBuffer(commandBuffer, 0);

        VkCommandBufferBeginInfo begin{};
        VulkanSDKobjects::CommandBufferBeginInfoInit(begin, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT);
        vkBeginCommandBuffer(commandBuffer, &begin);
    }

    void OneTimeCommands::EndRecordingAndSubmit()
    {
        vkEndCommandBuffer(commandBuffer);

        VkCommandBufferSubmitInfo commandBufferSubmit{};
        VulkanSDKobjects::CommandBufferSubmitInfoInit(commandBufferSubmit, commandBuffer);

        VkSubmitInfo2 queueSubmit{};
        queueSubmit.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
        queueSubmit.commandBufferInfoCount = 1;
        queueSubmit.pCommandBufferInfos = &commandBufferSubmit;

        vkQueueSubmit2(*submitQueue, 1, &queueSubmit, nullptr);
        vkQueueWaitIdle(*submitQueue);
    }




    void VulkanRenderer::AllocateImage(VulkanAllocatedImage& imageToAllocate, VkExtent3D imageExtent, 
        VkFormat imageFormat, VkImageUsageFlags imageUsage, bool bMipmapped /* =false */)
    {
        //Save the image extent and image format to the allocated image structure
        imageToAllocate.extent = imageExtent;
        imageToAllocate.format = imageFormat;

        //Create the Vulkan SDK vkImageCreateInfo object with the parameters given
        VkImageCreateInfo imageToAllocateInfo{};
        VulkanSDKobjects::ImageCreateInfoInit(imageToAllocateInfo, imageExtent, imageFormat, imageUsage);

        //Create the allocation info for vma 
        VmaAllocationCreateInfo imageAllocationInfo{};
        imageAllocationInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
        imageAllocationInfo.requiredFlags = VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        //Allocate the image
        vmaCreateImage(m_allocator, &imageToAllocateInfo, &imageAllocationInfo, &(imageToAllocate.image), 
        &(imageToAllocate.allocation), nullptr);

        //The aspect flags that will be used for the image view depend on if the image is a depth attahcment or not
        VkImageAspectFlags imageAspect{};
        (imageFormat == VK_FORMAT_D32_SFLOAT) ? imageAspect = VK_IMAGE_ASPECT_DEPTH_BIT : imageAspect = 
        VK_IMAGE_ASPECT_COLOR_BIT;
        VkImageViewCreateInfo imageViewInfo{};
        VulkanSDKobjects::ImageViewCreateInfoInit(imageViewInfo, imageToAllocate.image, imageAspect, imageFormat);

        //Create the image view
        vkCreateImageView(m_device, &imageViewInfo, nullptr, &(imageToAllocate.imageView));
    }




    void VulkanRenderer::LoadMeshBuffers(VulkanGPUMeshBuffers& meshBuffers, std::vector<VulkanVertex>& vertices, 
        std::vector<uint32_t>& indices)
    {
        VkDeviceSize vertexBufferSize = sizeof(VulkanVertex) * vertices.size();
        /*----------------------------------------------------------------------------------------
        Create the vertex buffer as an SSBO (that will accept a transfer from a staging buffer), 
        its memory will only be accessed by the GPU but shaders will have access
        -----------------------------------------------------------------------------------------*/
        AllocateBuffer(meshBuffers.vertexBuffer, vertexBufferSize, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | 
        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VMA_MEMORY_USAGE_GPU_ONLY);

        VkDeviceSize indexBufferSize = sizeof(uint32_t) * indices.size();
        //The index buffer will have the index buffer bit and will also accept a memory transfer
        AllocateBuffer(meshBuffers.indexBuffer, indexBufferSize, VK_BUFFER_USAGE_INDEX_BUFFER_BIT | 
        VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_ONLY);

        /*---------------------------------------------------------------------------------------------------
        Since the vertex buffer is only available in the gpu(shaders), the meshBuffers to save its address 
        to give it to the push constants so that the geometry can actually be drawn
        ----------------------------------------------------------------------------------------------------*/
        VkBufferDeviceAddressInfo vertexBufferAddressInfo{};
        vertexBufferAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
        vertexBufferAddressInfo.buffer = meshBuffers.vertexBuffer.buffer;
        meshBuffers.vertexBufferAddress = vkGetBufferDeviceAddress(m_device, &vertexBufferAddressInfo);

        //The buffers have been created, now the data needs to be passed to their gpu memory using a staging buffer
        VulkanAllocatedBuffer stagingBuffer;
        AllocateBuffer(stagingBuffer, vertexBufferSize + indexBufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, 
        VMA_MEMORY_USAGE_CPU_ONLY);

        //Map a void pointer to the staging buffer's memory, so that the vertex data can be loaded
        void* data = stagingBuffer.allocation->GetMappedData();

        //Put the vertices at the start of the memory address
        memcpy(data, vertices.data(), vertexBufferSize);
        //Place the indices after the vertices
        memcpy(reinterpret_cast<char*>(data) + vertexBufferSize, indices.data(), indexBufferSize);

        //Start recording copy commands
        m_instantSubmit.StartRecording();

        //Copy the vertices into the vertex buffer
        VkBufferCopy vertexBufferCopyRegion{0};
        vertexBufferCopyRegion.dstOffset = 0;
        vertexBufferCopyRegion.srcOffset = 0;
        vertexBufferCopyRegion.size = vertexBufferSize;
        vkCmdCopyBuffer(m_instantSubmit.commandBuffer, stagingBuffer.buffer, meshBuffers.vertexBuffer.buffer, 1, 
        &vertexBufferCopyRegion);

        //Copy the indices into the index buffer
        VkBufferCopy indexBufferCopyRegion{0};
        indexBufferCopyRegion.dstOffset = 0;
        indexBufferCopyRegion.srcOffset = vertexBufferSize;
        indexBufferCopyRegion.size = indexBufferSize;
        vkCmdCopyBuffer(m_instantSubmit.commandBuffer, stagingBuffer.buffer, meshBuffers.indexBuffer.buffer, 1, 
        &indexBufferCopyRegion);

        //Submit the commands
        m_instantSubmit.EndRecordingAndSubmit();

        //Free the memory of the staging buffer
        vmaDestroyBuffer(m_allocator, stagingBuffer.buffer, stagingBuffer.allocation);
    }

    void VulkanRenderer::AllocateBuffer(VulkanAllocatedBuffer& bufferToAllocate, VkDeviceSize bufferSize, 
    VkBufferUsageFlags bufferUsage, VmaMemoryUsage memoryUsage)
    {
        //Create the buffer's info
        VkBufferCreateInfo bufferInfo{};
        VulkanSDKobjects::BufferCreateInfoInit(bufferInfo, bufferSize, bufferUsage);

        //Create the allocation info
        VmaAllocationCreateInfo bufferAllocationInfo{};
        bufferAllocationInfo.usage = memoryUsage;
        //All buffer allocations will create a pointer to the allocation, available in the allocation info
        bufferAllocationInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;

        //Have vma allocate the buffer
        vmaCreateBuffer(m_allocator, &bufferInfo, &bufferAllocationInfo, &(bufferToAllocate.buffer), 
        &(bufferToAllocate.allocation), &(bufferToAllocate.allocationInfo));
    }




    void VulkanRenderer::DrawFrame()
    {
        if(m_pWindowData->bRendererShouldWait)
        {

        }

        /*-----------------------------------------------------------------------------
        Wait for the fence to be signalled at the end of the previous frame, 
        the fence was created with the signaled bit so the first frame won't deadlock
        -------------------------------------------------------------------------------*/
        vkWaitForFences(m_device, 1, &(m_frameToolList[currentFrame].inFlightFence), VK_TRUE, 100000000);

        vkResetFences(m_device, 1, &(m_frameToolList[currentFrame].inFlightFence));

        //Acquiring an image from the swapchain to present the render to the screen
        uint32_t swapchainImageIndex;
        vkAcquireNextImageKHR(m_device, m_bootstrapObjects.swapchainData.swapchain, 100000000, 
        m_frameToolList[currentFrame].imageAvailableSemaphore, VK_NULL_HANDLE, &swapchainImageIndex);

        //Make sure that the command buffer is clean and start recording commands
        vkResetCommandBuffer(m_frameToolList[currentFrame].renderCommandBuffer, 0);
        StartRecordingFrameCommands(m_frameToolList[currentFrame].renderCommandBuffer, swapchainImageIndex);

        //The color attachment parts of the commands should not be executed until an image is available
        VkSemaphoreSubmitInfo waitSemaphoreSubmit{};
        VulkanSDKobjects::SemaphoreSubmitInfoInit(waitSemaphoreSubmit, 
        m_frameToolList[currentFrame].imageAvailableSemaphore, VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR);

        //All types of commands that come after submitting the command buffer, should wait for this frame to finish
        VkSemaphoreSubmitInfo signalSemaphoreSubmit{};
        VulkanSDKobjects::SemaphoreSubmitInfoInit(signalSemaphoreSubmit, 
        m_frameToolList[currentFrame].renderFinishedSemaphore, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT);

        VkCommandBufferSubmitInfo commandBufferSubmit{};
        VulkanSDKobjects::CommandBufferSubmitInfoInit(commandBufferSubmit, m_frameToolList[currentFrame].renderCommandBuffer);

        //Submitting the command buffer along with sync object configurations
        VkSubmitInfo2 submitInfo{};
        VulkanSDKobjects::SubmitInfo2Init(submitInfo, &waitSemaphoreSubmit, &signalSemaphoreSubmit, &commandBufferSubmit);
        vkQueueSubmit2(m_queues.graphicsQueue, 1, &submitInfo, m_frameToolList[currentFrame].inFlightFence);

        VkPresentInfoKHR presentInfo{};
        VulkanSDKobjects::PresentInfoKHRInit(presentInfo, m_bootstrapObjects.swapchainData.swapchain, &swapchainImageIndex, 
        &m_frameToolList[currentFrame].renderFinishedSemaphore);
        vkQueuePresentKHR(m_queues.presentQueue, &presentInfo);

        //Set the currentFrame to the next one, but make sure it does not go over BLITZEN_MAX_FRAMES_IN_FLIGHT
        currentFrame = (currentFrame +1) % BLITZEN_MAX_FRAMES_IN_FLIGHT;
    }

    void VulkanRenderer::StartRecordingFrameCommands(const VkCommandBuffer& commandBuffer, 
    uint32_t swapchainImageIndex)
    {
        //Put the command buffer in the ready state
        VkCommandBufferBeginInfo commandBufferBegin{};
        VulkanSDKobjects::CommandBufferBeginInfoInit(commandBufferBegin, 
        VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT);
        vkBeginCommandBuffer(commandBuffer, &commandBufferBegin);

        //Draw the background
        DrawBackground(commandBuffer);

        //Before rendering geometry the draw extent needs to be set to the size of the window
        m_drawExtent.width = m_pWindowData->windowWidth;
        m_drawExtent.height = m_pWindowData->windowHeight;

        //We change the color attachment's layout so that it fits the next function's needs
        ChangeImageLayout(commandBuffer, m_colorAttachmentImage.image, VK_IMAGE_LAYOUT_GENERAL, 
        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);

        DrawGeometry(commandBuffer);

        //Change the image layout so that it can be used for data transfer
        ChangeImageLayout(commandBuffer, m_colorAttachmentImage.image, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, 
        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);

        //Change the image layout so that it can accept a data transfer
        ChangeImageLayout(commandBuffer, m_bootstrapObjects.swapchainData.swapchainImages[swapchainImageIndex], 
        VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);

        //Copy the color attachment image to the swapchain image so that it can be presented on the screen
        CopyImageToImage(commandBuffer, m_colorAttachmentImage.image, 
        m_bootstrapObjects.swapchainData.swapchainImages[swapchainImageIndex], VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, 
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, m_drawExtent, m_bootstrapObjects.swapchainData.swapchainExtent);

        ChangeImageLayout(commandBuffer, m_bootstrapObjects.swapchainData.swapchainImages[swapchainImageIndex], 
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);

        //Once all commands have been recorded the command buffer can be reset
        vkEndCommandBuffer(commandBuffer);
    }

    void VulkanRenderer::DrawBackground(const VkCommandBuffer& commandBuffer)
    {
        //Chnage the image layout so that it can be used for clearing the color of the screen
        ChangeImageLayout(commandBuffer, m_colorAttachmentImage.image, VK_IMAGE_LAYOUT_UNDEFINED, 
        VK_IMAGE_LAYOUT_GENERAL);

        VkClearColorValue clearColorValue{};
        clearColorValue = {0.0f, 0.0f, 0.0f, 1.0f};

        VkImageSubresourceRange subresourceRange{};
        VulkanSDKobjects::ImageSubresourceRangeInit(subresourceRange, VK_IMAGE_ASPECT_COLOR_BIT);

        vkCmdClearColorImage(commandBuffer, m_colorAttachmentImage.image, VK_IMAGE_LAYOUT_GENERAL, 
        &clearColorValue, 1, &subresourceRange);
    }

    void VulkanRenderer::DrawGeometry(const VkCommandBuffer& commandBuffer)
    {
        //Specify rendering attachments and start rendering
        VkRenderingAttachmentInfo colorAttachmentRenderingInfo{};
        VulkanSDKobjects::ColorRenderingAttachmentInfoInit(colorAttachmentRenderingInfo, 
        m_colorAttachmentImage.imageView, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
        VkRenderingInfo renderingInfo{};
        VulkanSDKobjects::RenderingInfoInit(renderingInfo, &colorAttachmentRenderingInfo, m_drawExtent, nullptr, 
        nullptr);
        vkCmdBeginRendering(commandBuffer, &renderingInfo);

        //Bind the pipeline that will be used for this surface
        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_placeholderPipeline);

        //Since this pipeline has a dynamic viewport and scissor, it has to be set at draw time
        VkViewport viewport = {};
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = static_cast<float>(m_drawExtent.width);
        viewport.height = static_cast<float>(m_drawExtent.height);
        viewport.minDepth = 0.f;
        viewport.maxDepth = 1.f;
        vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

        VkRect2D scissor = {};
        scissor.offset.x = 0;
        scissor.offset.y = 0;
        scissor.extent.width = m_drawExtent.width;
        scissor.extent.height = m_drawExtent.height;
        vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

        GPUPushConstant pushConstant;
        pushConstant.worldMatrix = glm::mat4(1.0f);
        pushConstant.vertexBuffer = m_placeholderMesh.vertexBufferAddress;
        vkCmdBindIndexBuffer(commandBuffer, m_placeholderMesh.indexBuffer.buffer, 0, VK_INDEX_TYPE_UINT32);
        vkCmdPushConstants(commandBuffer, m_placeholderPipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, 
        sizeof(GPUPushConstant), &pushConstant);

        vkCmdDrawIndexed(commandBuffer, 6, 1, 0, 0, 0);

        vkCmdEndRendering(commandBuffer);
    }

    void VulkanRenderer::ChangeImageLayout(const VkCommandBuffer& commandBuffer, VkImage& image, 
    VkImageLayout oldLayout, VkImageLayout newLayout)
    {
        VkImageMemoryBarrier2 imageMemoryBarrier{};
        imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
        imageMemoryBarrier.image = image;
        imageMemoryBarrier.oldLayout = oldLayout;
        imageMemoryBarrier.newLayout = newLayout;

        imageMemoryBarrier.srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
        imageMemoryBarrier.srcAccessMask = VK_ACCESS_2_MEMORY_WRITE_BIT;
        imageMemoryBarrier.dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
        imageMemoryBarrier.dstAccessMask = VK_ACCESS_2_MEMORY_WRITE_BIT | VK_ACCESS_2_MEMORY_READ_BIT;

        VkImageAspectFlags aspectMask;
        (newLayout == VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL) ? aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT : 
        aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        VkImageSubresourceRange subresource{};
        VulkanSDKobjects::ImageSubresourceRangeInit(subresource, aspectMask);
        imageMemoryBarrier.subresourceRange = subresource;

        VkDependencyInfo dependency{};
        dependency.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
        dependency.imageMemoryBarrierCount = 1;
        dependency.pImageMemoryBarriers = &imageMemoryBarrier;

        vkCmdPipelineBarrier2(commandBuffer, &dependency);
    }

    void VulkanRenderer::CopyImageToImage(const VkCommandBuffer& commandBuffer, VkImage& srcImage, 
    VkImage& dstImage, VkImageLayout srcImageLayout, VkImageLayout dstImageLayout, VkExtent2D srcImageSize, 
    VkExtent2D dstImageSize)
    {
        VkImageBlit2 blit{};
        blit.sType = VK_STRUCTURE_TYPE_IMAGE_BLIT_2;

        blit.srcOffsets[1].x = srcImageSize.width;
        blit.srcOffsets[1].y = srcImageSize.height;
        blit.srcOffsets[1].z = 1;

        blit.dstOffsets[1].x = dstImageSize.width;
        blit.dstOffsets[1].y = dstImageSize.height;
        blit.dstOffsets[1].z = 1;

        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	    blit.srcSubresource.baseArrayLayer = 0;
	    blit.srcSubresource.layerCount = 1;
	    blit.srcSubresource.mipLevel = 0;

	    blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	    blit.dstSubresource.baseArrayLayer = 0;
	    blit.dstSubresource.layerCount = 1;
	    blit.dstSubresource.mipLevel = 0;

        VkBlitImageInfo2 blitInfo{};
        blitInfo.sType = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
        blitInfo.srcImage = srcImage;
        blitInfo.dstImage = dstImage;
        blitInfo.srcImageLayout = srcImageLayout;
        blitInfo.dstImageLayout = dstImageLayout;
        blitInfo.regionCount = 1;
        blitInfo.pRegions = &blit;
        blitInfo.filter = VK_FILTER_LINEAR;

        vkCmdBlitImage2(commandBuffer, &blitInfo);
    }




    void VulkanRenderer::CleanupResources()
    {
        vkDeviceWaitIdle(m_device);

        m_placeholderMesh.CleanupResources(m_device, m_allocator);
        vkDestroyPipeline(m_device, m_placeholderPipeline, nullptr);
        vkDestroyPipelineLayout(m_device, m_placeholderPipelineLayout, nullptr);

        CleanupImages();

        for(size_t i = 0; i < BLITZEN_MAX_FRAMES_IN_FLIGHT; ++i)
        {
            m_frameToolList[i].CleanupResources(m_device);
        }

        m_instantSubmit.CleanupResources(m_device);

        CleanupVulkanBootstrapObjects();
    }

    void VulkanRenderer::CleanupImages()
    {
        m_colorAttachmentImage.CleanupResources(m_device, m_allocator);
        m_depthAttachmentImage.CleanupResources(m_device, m_allocator);
    }

    void FrameTools::CleanupResources(const VkDevice& device)
    {
        vkDestroyCommandPool(device , renderCommandPool, nullptr);

        vkDestroyFence(device, inFlightFence, nullptr);
        vkDestroySemaphore(device, renderFinishedSemaphore, nullptr);
        vkDestroySemaphore(device, imageAvailableSemaphore, nullptr);
    }

    void OneTimeCommands::CleanupResources(const VkDevice& device)
    {
        vkDestroyCommandPool(device, commandPool, nullptr);
    }

    void VulkanAllocatedImage::CleanupResources(const VkDevice& device, const VmaAllocator& allocator)
    {
        vkDestroyImageView(device, imageView, nullptr);
        vmaDestroyImage(allocator, image, allocation);
    }

    void VulkanAllocatedBuffer::CleanupResources(const VkDevice& device, const VmaAllocator& allocator)
    {
        vmaDestroyBuffer(allocator, buffer, allocation);
    }

    void VulkanGPUMeshBuffers::CleanupResources(const VkDevice& device, const VmaAllocator& allocator)
    {
        vertexBuffer.CleanupResources(device, allocator);
        indexBuffer.CleanupResources(device, allocator);
    }

    void VulkanRenderer::CleanupVulkanBootstrapObjects()
    {
        //Since the swapchain data was also created with vkBootstrap, it will be destroyed here
        CleanupSwapchainData();
        //The allocator must be destroyed late, so that its allocation can be freed first
        vmaDestroyAllocator(m_allocator);
        //The device is one of the last objects to be destroyed since it is called for all other object destructors
        vkDestroyDevice(m_device, nullptr);
        //The surface needs to be destroyed before the instance
        vkDestroySurfaceKHR(m_bootstrapObjects.vulkanInstance, m_bootstrapObjects.windowSurface, nullptr);
        //The debug messenger can be destroyed right before the instance, it has no other dependencies
        vkb::destroy_debug_utils_messenger(m_bootstrapObjects.vulkanInstance, m_bootstrapObjects.debugMessenger, nullptr);
        //The Vulkan Instance will be destroyed last
        vkDestroyInstance(m_bootstrapObjects.vulkanInstance, nullptr);
    }

    void VulkanRenderer::CleanupSwapchainData()
    {
        //Save the image views to a reference to the original array, so that I don't have to write the other thing 3 times
        std::vector<VkImageView>& swapchainImageViews = m_bootstrapObjects.swapchainData.swapchainImageViews;
        //Destroy all swapchain image views
        for(size_t i = 0; i < swapchainImageViews.size(); ++i)
        {
            vkDestroyImageView(m_device, swapchainImageViews[i], nullptr);
        }
        //Now that the image views have been destroyed, the swapchain will also be destroyed which will also cleanup its images
        vkDestroySwapchainKHR(m_device, m_bootstrapObjects.swapchainData.swapchain, nullptr);
    }
}